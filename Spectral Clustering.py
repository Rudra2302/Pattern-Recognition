# -*- coding: utf-8 -*-
"""PRML assignment Q2c

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zvn5_kRsd3p1bHjsYAomZrejkUuIcZfE

Import the required packages
"""

import numpy as np
import matplotlib.pyplot as plt
import random
import math

"""Import the dataset"""

import pandas as pd
df = pd.read_csv('csv_dataset.csv')

"""Access the X and Y values"""

X=np.array(df['-1.2061'])
X=np.append(X,-1.2061)
Y=np.array(df['-2.5268'])
Y=np.append(Y,-2.5268)
Y.shape

"""COmpute the means"""

mean=[np.mean(X), np.mean(Y)]
sigma = 1
mean

"""Define functions for polynomial and radial basis functions"""

def phi(x1,y1,x2,y2): # polynomial function
  temp=(x1*x2+y1*y2+1)**2
  return temp

def rbf(x1,y1,x2,y2): # radial basis function
  temp = (x1-x2)**2 + (y1-y2)**2
  temp = temp/(2*sigma*sigma)
  ans = math.exp(-temp)
  return ans

"""Find the matrix K"""

K = np.empty((1000,1000))

for i in range(1000):
  for j in range(1000):
    K[i][j] = rbf(X[i],Y[i],X[j],Y[j])

"""Get the eigenvalues and eigenvectors"""

lambd, w = np.linalg.eig(K)
lambd = np.real(lambd) # to make sure the samll imaginary values dont cause a problem
w = np.real(w)

"""Sort the eigenvectos based on eigenvalues"""

lambd_ind = np.argsort(lambd)[::-1] # argsort lambda
lambd = np.sort(lambd)[::-1] # sort lambda
w = w[:, lambd_ind] # sort w

"""Solution for the H vector is the top 2 eigenvectors"""

H = np.empty((1000,2))
H[:,0] = w[:,0] # top 2 eigenvalue vectors
H[:,1] = w[:,1]

"""Normalize each row of the H matrix"""

for i in range(1000): # row-normalize the H matrix
  norm = math.sqrt(H[i][0]**2 + H[i][1]**2)
  H[i][0] = H[i][0]/norm
  H[i][1] = H[i][1]/norm

"""Define k and initialize means"""

k = 2 # no of clusters
means_init = random.sample(range(0, 1000), k)
means_init

"""Initialize the means and cluster array"""

cluster = np.empty((1000)) # cluster array
mu = np.empty((k,2))
for i in range(k): # initialize means
  mu[i][0] = H[means_init[i]][0]
  mu[i][1] = H[means_init[i]][1]

"""RUn Lloyd's algorithm with rows as the dataset"""

error1 = 1
error2 = 0
it = 0
n = np.zeros(k)

while error1 != error2:
  error1=error2
  error2=0
  it+=1

  for i in range(1000): # re-assignment of clusters
    min_dist=0
    for j in range(k):
      dist = (H[i][0]-mu[j][0])**2 + (H[i][1]-mu[j][1])**2
      if j == 0:
        min_dist = dist
        cluster[i] = 0
      elif dist < min_dist:
        min_dist = dist
        cluster[i] = j

  for j in range(k):
    mu[j] = [0,0]
    n[j] = 0

  for i in range(1000): # re-calculation of cluster centres
    c = int(cluster[i])
    mu[c][0] += H[i][0]
    mu[c][1] += H[i][1]
    n[c]+=1

  for j in range(k):
    if n[j] == 0:
      mu[j][0] = 0
      mu[j][1] = 0
      continue
    mu[j][0] = mu[j][0]/n[j]
    mu[j][1] = mu[j][1]/n[j]

  for i in range(1000): # calculation of error
    c = int(cluster[i])
    dist = (H[i][0]-mu[c][0])**2 + (H[i][1]-mu[c][1])**2
    error2+=dist

"""Plotting the clusters"""

colors = ['blue', 'red', 'green', 'yellow', 'orange']
plt.ylim(-1,1)
for i in range(k):
  plt.scatter(H[cluster == i][:,0], H[cluster == i][:,1], color={colors[i]}, label=f'Cluster{i}')

plt.title(f'Spectral K-Means with k=2 and radial basis\n kernel with sigma=1. Error={round(error2,3)}')
plt.xlabel('X values')
plt.ylabel('Y values')
plt.legend(title='Clusters')

"""Spectral CLustering with a different method

Assign clusters without Lloyd's Algorithm
"""

for i in range(1000):
  if H[i][0] > H[i][1]: # assign to the cluster with higher H value
    cluster[i] = 0
  else:
    cluster[i] = 1

"""Plot the clusters"""

colors = ['blue', 'red', 'green', 'yellow', 'orange']
plt.ylim(-1,1)
for i in range(k):
  plt.scatter(H[cluster == i][:,0], H[cluster == i][:,1], color={colors[i]}, label=f'Cluster{i}')

plt.title('Spectral K-Means with k=2 and radial basis\n kernel with sigma=1. Without Lloyds Algorithm')
plt.xlabel('X values')
plt.ylabel('Y values')
plt.legend(title='Clusters')

